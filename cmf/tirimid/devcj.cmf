DOC-TITLE The Development of Cubic Jumping
DOC-CREATED 2025-04-14

=Introduction

    If you are not already familiar, some time ago I released a game titled
Cubic Jumping, an abstract-style speedrun / rage platformer. This game was
developed over about six months with on-and-off effort. The game runs on Windows
and Linux systems and can be downloaded at @[https://tirimid.itch.io/cubic-jumping|the itch.io page].
The complete source code for the game is available at the itch.io page as well
as on @[https://github.com/tirimid/cubic-jumping|the GitHub]. It was an
immensely fun project to work on, and I think the result is satisfactory and
reasonably high quality.
    In this article I hope to explain how I developed Cubic Jumping, what I
learnt, and lay out a comprehensive history of the game's development. The
contents are also entirely retrospective rather than realtime.

=Prehistory

    Why did I make Cubic Jumping? Why did I call it that? Why does the art style
look the way it does? These questions are all answered by what I call "Old Cubic
Jumping". Back when I had just started trying to make games, I was learning the
Unity 2D Engine, and I decided to make a simple 1-level platformer game called,
well, Cubic Jumping. Due to not knowing how to make quality assets, I just went
with simple colored squares - a red player and a black tilemap environment, all
on a gray background.
    Hence was decided the style for Cubic Jumping, several years before I even
decided to create it.

=Starting Off

    At first, the game was built using my build system, mincbuild, and licensed
under the MIT license. Both of these things eventually changed and the project
was relicensed under the GNU GPLv3.

=Player Movement

    In order to even design player movement, you need to decide on an physics
tick. In the case of Cubic Jumping, there is a single tickrate, 100TPS, that is
used for everything, including player movement and logic. This value directly
determines basically everything regarding how the game feels.
    At first, player movement was not configurable, and the key input was
hardcoded - users could not rebind movement to something they preferred. There
was a basic and flawed tilemap collision detection system which endured with
minor changes through the entire game's life.
    The collision works on this principle:

#The player is known to be within the bounds of the map.
#This means that the player will always have a tile above, below, left and right
 of them.
#We can get the positions of these tiles.
#The player has an x-axis and y-axis velocity which are independent of each
 other.
#If, on any given tick, the player will move into / through a tile due to their
 high velocity, we can check this by comparing, e.g. (player position + player
 velocity <= left tile pos + 1).
#If the player would collide, we resolve the collision by zeroing the velocity
 along that axis and setting the players position such that they are directly
 next to the wall.
#Otherwise, player position += player velocity.

    This does not work well when the player would run into a corner, and this
indeed caused issues on some playtests. However, for quite a long time, this
collision algorithm was suitable.

*(INSERT DIAGRAM OF ALGORITHM)*

    There are two other aspects that changed substantially between the initial
and release versions. Initially, the jumping and powerjumping would continue
indefinitely while the keys were held and did not need to be buffered, and the
downwards dash was more of a "fast fall" which did nothing but increase the
effect of gravity on the player. The feel of the game was rather different.

=Map Editor and Map List

    One part of a complete platformer game is a progression of maps on the
player side. That is, the player has to click play, beat a level, and move onto
the next level of a predetermined sequence. Cubic Jumping uses the Map List to
do this. The Map List is literally an array of map structures placed in sequence
along with an index into the current map being played. When the user reaches the
end, the index is incremented and some behavior is triggered (e.g. move onto the
next level).
    In new versions, the Map List also provides some information about each map,
such as names or par times. User levels, on account of not being baked into the
game, cannot be accessed from the Map List.
    All maps, official and user-generated, are created using the level editor.
Here is the first insight I figured out - if it is applicable, make a map editor
for your game as soon as you can. The earliest test levels were manually written
out by punching values into the map file. As you can imagine, it was such a pain
that I couldn't take it anymore and just make an editor.
    The first editor was so rudimentary that it was nearly unusable. No panels,
everything is done using undocumented and arcane keyboard shortcuts - in short,
terrible. However, it was such an upgrade over punching values into a text file
that I was finally able to make real test maps for real features.

*(INSERT SCREENSHOT OF INITIAL LEVEL EDITOR)*

    Make a level editor.
